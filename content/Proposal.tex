\section{Modeling Paradigms}
\label{sec:Paradigms}

\todo[inline]{
\textbf{Definition}\\
\textbf{Example}\\
\textbf{Running Example}
}

\begin{definition}[Paradigm]
    A paradigm $P\in \mathbb{P}$ is a pair $P = (\rho, \pi)$ where
    \begin{itemize}
        \item $\rho = (F, W, I/G, \sigma) \in \mathcal{F}\times \mathcal{W} \times \mathcal{I} \times \Sigma$ is a \emph{candidate paradigm}, with
        \begin{itemize}
            \item $F\in\mathcal{F}$ is a set of formalism (cf. \S \ref{sec:Formalism});
            
            \item $W\in \mathcal{W}$ is a set of workflows (cf. \S \ref{sec:Workflow});
            
            \item $I/G\in \mathcal{I}$ is a set of intents, or goals (cf. \S \ref{sec:Intent-Goal});
            
            \item $\sigma =(\sigma_{F}, \sigma_{W}, \sigma_{I/G}) \in \Sigma$ is a family of relationships between formalisms, between workflows and between intents/goals;
        \end{itemize}
        and $\pi\in \Pi$ a set of properties on all the components of $\rho$. 
    \end{itemize}
    $\rho$ qualifies as a \emph{valid} paradigm iff $\rho$ validates the properties of $\pi$.
\end{definition}


\subsection{Formalism}
\label{sec:Formalism}

Based on the definition of a formalism given in Broman et.al.~\cite{BromanViewpointsformalismslanguages2012}, we formally define a formalism as:
\begin{definition}[Formalism]
    $$F = (AS, \llbracket ~ \rrbracket) $$  where (AS = Abstract syntax, $\llbracket ~ \rrbracket$ = Semantics)
\end{definition}


\begin{definition}[Formalism-Properties]
    Each formalism exposes certain properties, that define how and where it can be used (e.g. it is timed/untimed, continuous/discrete/hybrid, etc.).
    These properties help moving from one formalism to another, find similar formalisms and help characterising the transformations.
\end{definition}

\paragraph{Example formalisms}
\begin{itemize}
    \item Ordinary differential equations
    \item Timed Automata
    \item Cellular Automata
    \item Stochastic Petri Nets
\end{itemize}

% \todo[inline]{
% \textbf{Definition}\\
% \textbf{Example}\\
% \textbf{Running Example}
% }

\subsection{Workflow}
\label{sec:Workflow}

Workflows describe the actions and artefacts that are involved in the process.

Transformations are similar to Activity diagram's actions (can be automatic, semi or manual)

Models are similar to Activity diagram's Objects.

\paragraph{Examples:}
\begin{itemize}
    \item HPI CPSlab fragment
    \item Agile/Waterfall
\end{itemize}

\paragraph{Counter-Examples:}
\begin{itemize}
    \item MBSE/MDSE
\end{itemize}


\subsection{Intent / Goal}
\label{sec:Intent-Goal}

There's a relation to Requirements here. Look at Requirements languages (i*, GRL, \dots)

\begin{definition}[Intent]
    An intent answers ``What is my goal?'' and ``What are the beliefs, i.e.. design rationales?''
\end{definition}

\todo[inline]{
\textbf{Definition}\\
\textbf{Example}\\
\textbf{Running Example}
}

\subsection{Relation}
\label{sec:Relation}

\todo[inline]{
\textbf{Definition}\\
\textbf{Example}\\
\textbf{Running Example}
}

\subsection{Properties}
\label{sec:Properties}

\todo[inline]{
\textbf{Definition}\\
\textbf{Example}\\
\textbf{Running Example}
}

\section{Multi-Modeling Paradigms}
\label{sec:Multi-Paradigms}

\todo[inline]{
TO BE THOUGHT OF!
}

\newpage
We postulate that a more formal definition of \textit{paradigm} should be shaped as a set of logical bindings between the set of modeling \textit{formalisms} involved in a given modeling approach, the set of \textit{relationships} between the used models based on the selected formalisms, the \textit{workflow(s)} used to manipulate such models respecting the established relationships and the \textit{intents and goals} that drive the manipulations and state the desired results of the whole modeling process.
\textit{Conformity to a paradigm} should then be expressed in terms of the validity of a set \textit{properties} over those 4 elements.

We argue such a definition, that still lacks the notion of \textit{primitive paradigm}, by looking at a number of popular model-based approaches, that are characterized (and recognizable) by these four aspects, in explicit or tacit conformance to formally or informally defined practices. Let us consider as examples of candidate modeling paradigms Agile Programming (AP) \cite{}, Model Based Software Engineering (MBSE) \cite{}, Model Driven Software Engineering (MDSE) \cite{}, Roundtrip Software Engineering (RSE) \cite{}, that are well known software development methodologies, and, as diverse elements, Reverse Engineering (RE) \cite{} and Multi Formalism Modeling\footnote{Multi Formalism Modeling is the generic denomination of a family of different approaches that are founded onto enabling the modeling of a system by means of different modeling formalism, that may be coordinately used for different aspects, different subsystems, different components or different modeling stages of a system.} (MFM) \cite{MauroChapter}, that is oriented to performance evaluation, as working examples.

With no claim for a complete analysis of goals and intents, AP, MBSE, MDSE and RSE share a common goals, that is the production of software artifacts. MBSE, MDSE and RSE share an intent, that is the will for supporting the team in obtaining shareable, clear, verifiable, extensible, evolveable, documentation oriented design artifacts by the adoption of a formal notation, with the additional goal of a certifiable process and a quality final result, while AP has the intent of simplifying the team organization and management and supporting a fast and continuous development and release process including frequent user revisions, with the additional goal of a continuous deployment, rather than an incremental approach. MDE has the additional goal of automatic code generation by transformation with the intent of avoiding human generated errors along the development process, while RSE has the additional goal of a complete and automatic equivalence between models and code, with the intent of completely automating both code generation and model maintenance.

RE instead has the goal of obtaining models from code, by means of a manual, semi-automated or automated analysis, with the intent of producing missing documentation or artifacts that may be used to reengineer the code or include legacy code into new projects. Finally, MFM as the goal of producing a performance estimation of a given system, with the intent of supporting the design process of the system with quantitative exploration of its characteristics to guide decisions when alternative solutions are possible.

In all cases there is a set of formalisms\footnote{The term \textit{formalism} here both stays for actually fully formal specified modeling language or for semi-formal modeling languages (such as the widely adopted Entity/Relationship modeling language).} that are adopted to generate models supporting the approach. MBSE, MDSE, RSE and RE generally adopt the Unified Modeling Language (UML) as the set of support formalisms, or a subset or custom variant of UML, while AP generally relies on the use of code as a model, and MFM approaches rely on a various, generally extensible set of formalisms, depending on the application, that may encompass UML itself or some annotated or extended variants of it, but that is anyway not specifically agreed in literature.

Exploring relationships between the formalisms used in each of these approaches would be long and tedious, but we argue that relationships are characteristics of a modeling paradigm because different modeling approaches that share a set of modeling paradigms make a different use of them and coordinate models founded on them in a different way, yet keep being sound and fit for their intents and goals. In some cases these relationships are clearly formally stated by the approach (e.g. MDE and RTSE rely on formally defined automatic model transformations), in other cases the modelers have the freedom to customize or propose the relationships (e.g. MBSE, in which at least code production is not obtained by a strict mapping of models and code), according to own modeling style or to the domain, in other cases a formal definition of them is prescribed by certification processes, in other cases relationships emerge or may be custom built by exploiting some properly designed mechanism (e.g. OsMoSys \cite{OsMoSys} and SIMTHESys \cite{SIMTHESys} MFM approaches found relationships between formalisms on metamodeling). Anyway, coordination practices or best practices of models in a project described in different formalisms do implicitly define such relationships.

Workflows drive and depict the practices used in the different approaches, partially expliciting relationships and describing how models are applied, revised, transformed, reused, composed, evolved legitimately in the chosen approach. Literature and practice provide both structured and non-structured approaches, while we argue that structured workflows are needed to comply to our definition.

TODO: A comparison table and a more detailed analysis on the same line

TODO: Figure depicting MBSE, MDSE, RSE and RE as from Paris

\subsection{The way for a formal definition}

In order to get to a formal definition of paradigm, we need to formalize this analysis framework. This includes the establishment of an analysis procedure for the candidate paradigms that includes the definition of upper and lower abstraction bounds, in terms of what is the most elementary paradigm possible (a \textit{primitive paradigm}) and what is so complex to be actually the result of the joined application of multiple paradigms (a \textit{multiparadigm}).

A possible interpretation of the idea of primitive paradigm may be a simple single formalism modeling process, such as Differential Equations (DE), Petri Nets (PN), Fault Trees (FT), or a programming language: all these cases have a simple and well defined goal and intent, use one formally defined formalism to allow the design of models, have a straightforward workflow (if considering as the workflow the practical process of writing a model).

A possible definition of multiparadigm can be shaped by leveraging the need for a semantic approach when joining together concepts from different domains. This need derives from the fact that a mapping between modeling entities in different areas is only possible by considering the meaning of such entities in their domain and the meaning of the logical binding built by the modeler when deciding to coordinate different paradigms to get to a more significant and comprehensive conceptual modeling tool. One may argue that structured approaches like MBSE already bind by workflows concepts that may be considered belonging to different domains, by associating different models in a workflow: nevertheless, our opinion is that the semantic binding should not be trivial, that is, it should be not induced by the fact that different models are simply different specialized views on the same object, or that it should not be related to modeling a different characteristic of a same entity. Alternatively, less strict criteria may be used than strong semantic boudaries, considering that there is anyway the need for a notion of \textit{meaningful multiparadigm}: for example, the classical Waterfall Development Model (WDM) for software and AP cannot be joined into a multiparadigm, as they share the same main goal, that is the production of software artifacts, but they have conflicting intents, as the first one foresees a structured, "heavy", integral development process, while the second is based on incremental, non-structured, evolutive development).

On the basis of the four elements presented in the beginning of this Section, we propose the following definition: \textit{A paradigm is a coherent system of modeling formalisms, relationships between formalisms, workflows that allow model manipulations with stated intents and precise goals, all characterized by a set of properties}; a paradigm can be thus formally expressed as $P=\{\langle F,W,I,G>, \mathcal{R}, \pi \}$, where $F$ is the set of formalisms, $W$ is the set of workflows, $I$ is the set of intents, $G$ is the set of goals, $\mathcal{R}$ is the set of relationships, $\pi =\{p_i\}$ is the set of reference properties, **** named \textit{constraints} ****, that characterize paradigm $P$. A coherency with $\{p_i\}$ check on a generic quadruple with the same structure of $<F,W,I,G>$, to verify if such quadruple is coherent with $P$, must be performed by a proper \textit{coherency function} $\models$. Analogously, a multiparadigm $MP=P_1 \times P_2$, characterized by $\{<F_\mathit{MP},W_{MP},I_{MP},G_{MP}>, \mathcal{R}_{MP}, \pi_{MP}\}$, is a combination of 2 (or more) paradigms $P_1$ and $P_2$, characterized by $\{< F_1,W_1,I_1,G_1>, \mathcal{R}_1 , \pi_1\}$ and $\{<F_2,W_2,I_2,G_2>, \mathcal{R}_2, \pi_2\}$: to completely define a multiparadigm we need a definition of the relationship between $<F_{MP},W_{MP},I_{MP},G_{MP}>$ and the couple $(< F_1,W_1,I_1,G_1>,<F_2,W_2,I_2,G_2>)$, and the notion of metaconstraints to represent $\pi_{MP}$, that may not simply be a combination of $\pi_1$ and $\pi_2$, e.g. if the semantic approach is taken as the basis for delimiting the border between paradigms and a multiparadigm **** what about $\mathcal{R_{MP}}$, $\mathcal{R}_1$ and $\mathcal{R}_2$? ****. Multiparadigm also need an extension of the notion of coherency used in the proposed definition of paradigm.

The coherency relation itself needs a definition. It can be defined as specific to a given paradigm, thus introducing a $\models_i$ for each paradigm $P_i$, or as an universal notion applicable to all paradigm in the same way: and it is significant, from an operative point of view, if coherency with metaconstraints should be a decision procedure over properties to be performed by humans of computers, as it implies a different degree of formalization of the notion of coherence and of the notion of metaconstraints.

TODO: What is the relationship between paradigm and methodology?
