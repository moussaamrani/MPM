\section{Modeling Paradigms}
\label{sec:Paradigms}
\todo[inline]{Responsibles: 
Formalization:MA, HG
Examples DB}
\todo[inline]{
\textbf{Definition: Notes from HG: My understanding is that an extension/generalisation of the Software Manufacture Models and its notion of Software Manufacture Model Patterns from \cite{HebigPhD2014} would be helpful here.See Figure 6.12.: Meta model of Software Manufacture Model language and Figure 6.22.: Meta model of
Software Manufacture Model Pattern language}\\
\textbf{Example}\\
\textbf{Running Example: use Matlab/Simulink without stateflow and simulation}
}
\todo[inline]{Notes from HG: 
ADDED:
- add relational view for a paradigm = relations between these models
- add workflow offered by each paradigms = modeling scenarios (maybe workflow/process fragments);
mega models and mega model fragments can be employed to describe approaches (see Regina Hebigâ€™s
work)
- add intents/goals supported by a paradigm = modeling intents
BUT: here emphasis is on the combination at the level of the formalisms!
STILL to be ADDED:
- scenario may employs part of the workflow offered by each paradigms to realize a new partial workflow
(e.g., offer a workfow to do a simulation for the joint models that employs steps of workflows for simulate the
separate models)
- combine intents/goals supported by each paradigms (e.g, allow validation of a combined view based on the
validation capabilities for each paradigm on its own)
- combine relational view elements offered by each paradigms into joint relational view elements (e.g, allow
optimization of a combined view for criteria provided for each paradigm or criteria for their combination)}

\todo[inline]{Notes from HG: Special cases:
-single-formalism paradigm is a paradigm employing only a single formalism
-multi-formalism paradigm is a paradigm employing multiple formalisms}

\begin{definition}[Paradigm]
    A paradigm $P\in \mathbb{P}$ is a pair $P = (\rho, \pi)$ where
    \begin{itemize}
        \item $\rho = (F, W, I/G, \sigma) \in \mathcal{F}\times \mathcal{W} \times \mathcal{I} \times \Sigma$ is a \emph{candidate paradigm}, with
        \begin{itemize}
            \item $F\in\mathcal{F}$ is a set of formalism (cf. \S \ref{sec:Formalism});
            
            \item $W\in \mathcal{W}$ is a set of workflows (cf. \S \ref{sec:Workflow});
            
            \item $I/G\in \mathcal{I}$ is a set of intents, or goals (cf. \S \ref{sec:Intent-Goal});
            
            \item $\sigma =(\sigma_{F}, \sigma_{W}, \sigma_{I/G}) \in \Sigma$ is a family of relationships between formalisms, between workflows and between intents/goals;
        \end{itemize}
        and $\pi\in \Pi$ a set of properties on all the components of $\rho$. 
    \end{itemize}
    $\rho$ qualifies as a \emph{valid} paradigm iff $\rho$ validates the properties of $\pi$.
\end{definition}


\subsection{Formalism}
\label{sec:Formalism}


\subsubsection{Definition}
\label{sec:Formalism-Definition}

A \emph{formalism} is intuitively a \emph{mathematical object} 
\cite{BromanViewpointsformalismslanguages2012} that describes a set of concepts,
as well as their relationships, and rules for manipulating them consistently. As
such, a formalism is similar to a \emph{language}, but lacks a proper 
\emph{concrete syntax}: often, plain mathematics is used to describe the 
concepts and their manipulation. 

\begin{definition}[Formalism]
   A \emph{formalism} $F \in \mathcal{F}$ is a triple $F = (\mathsf{AS}, \mathbb{D}, \mu)$ 
	where: 
	\begin{itemize}
		\item $\mathsf{AS}$ is an \emph{abstract syntax} defining the core concepts, as 
		well as their relationships, called \emph{abstract components} of the 
		formalism;
		
		\item $\mathbb{D}$ is the \emph{semantic domain}, viewed as a mathematical set that 
		gives meaning to the concepts in \textsf{AS} via
		
		\item $\mu \colon \mathsf{AS} \to \mathbb{D}$, the \emph{semantic mapping}.
	\end{itemize}
\end{definition}
The abstract syntax is itself captured by a \emph{structural language}: the 
\textsc{Omg} Class Diagram, the Entity/Relation language, etc. The semantic mapping
unambiguously maps each abstract concept (or a combination of several related 
abstract concepts) to elements of $\mathbb{D}$ through the traditional semantic 
techniques: \emph{operational}, \emph{translational} or \emph{axiomatic} 
\cite{}. 



A \emph{language} is the computer counterpart of formalisms, in the sense that 
they represent concrete implementations. As a direct consequence, a language differs
from a formalism in the sense that it provides a computer-friendly 
\emph{concrete syntax} (which requires, for example, to remove any greek symbols 
in order to stick to a specific file encoding). 

A language 


sticking to a specific encoding of character instead of greek symbols), and to make
implementation choices on how to efficiently represent the semantic domain 
$\mathbb{D}$. These choices may introduce slight deviations in the semantics 
(both in the domain and the mapping), and/or may implement several variations in 
the semantics (for example, using different solvers for a semantic domain for time, 
that may change the overall semantics) \cite{BromanViewpointsformalismslanguages2012}.




\subsubsection{Characteristics}
\label{sec:Formalism-Characteristics}

\begin{definition}[Formalism-Properties]
    Each formalism exposes certain properties, that define how and where it can be used (e.g. it is timed/untimed, continuous/discrete/hybrid, etc.).
    These properties help moving from one formalism to another, find similar formalisms and help characterising the transformations.
\end{definition}


\subsubsection{Examples}
\label{sec:Formalism-Examples}

\begin{itemize}
    \item Ordinary differential equations
    \item Timed Automata
    \item Cellular Automata
    \item Stochastic Petri Nets
\end{itemize}

% \todo[inline]{
% \textbf{Definition}\\
% \textbf{Example}\\
% \textbf{Running Example}
% }

\subsection{Workflow}
\label{sec:Workflow}
Workflows describe the actions and artefacts that are involved in the process.

Transformations are similar to Activity diagram's actions (can be automatic, semi or manual)

Models are similar to Activity diagram's Objects.

\paragraph{Examples:}

\todo[inline]{Example: Simulation of a Matlab/Simulink model and subsequent adjustments}

\begin{itemize}
    \item HPI CPSLab fragment
    \item Agile/Waterfall
\end{itemize}

\paragraph{Counter-Examples:}
\begin{itemize}
    \item MBSE/MDSE
\end{itemize}


\subsection{Intent / Goal}
\label{sec:Intent-Goal}
\todo[inline]{Responsible DBl: There's a relation to Requirements here. Look at Requirements languages (i*, GRL, \dots)}

\begin{definition}[Intent]
    An intent answers ``What is my goal?'' and ``What are the beliefs, i.e.. design rationales?''
\end{definition}

\todo[inline]{
\textbf{Definition: modeling intents is meant in a broad sense including analysis steps such as simulation etc.}\\
\textbf{Example}\\
\textbf{Running Example}
}

\subsection{Relation}
\label{sec:Relation}

\todo[inline]{
See later when we have a more detailed example\\
\textbf{Definition}\\
\textbf{Example}\\
\textbf{Running Example}
}

\subsection{Properties}
\label{sec:Properties}

\todo[inline]{
See later when we have a more detailed example\\
\textbf{Definition}\\
\textbf{Example}\\
\textbf{Running Example}
}

\section{Multi-Modeling Paradigms}
\label{sec:Multi-Paradigms}
\todo[inline]{Responsibles: HG and MI}
\todo[inline]{
MI: Check the text and move it to the appropriate sections
}
\todo[inline]{
MI: The difference between a "complex" paradigm and a multiparadigm is the need, in the second case, for a non-trivial, explicit binding between concepts belonging to the domain of the different involved paradigms, that cannot be simply implemented as relationships, and forms the "glue" between the paradigms.
}

\todo[inline]{From HG's document:

Definition 4 (relations between paradigms, core paradigm, multi-paradigm) A paradigm can support the different
dimensions of systems to such an extent that it conceptually equals another paradigm when it supports for
the same dimensions exactly the same features. A paradigm can support the different dimensions of systems to
such an extent that it conceptually includes another paradigm when it supports all features of all dimensions that
the other paradigm supports and is not equal. A paradigm can support the different dimensions of systems to such
an extent that it conceptually different from another paradigm when it supports different dimensions or different
features for the same dimension. A core paradigm is then a paradigm that is not a conceptual extension of another
paradigm (it does not exists a paradigm it conceptually includes). A multi-paradigm is then a paradigm that does
conceptual include multiple core paradigms.

IMPORTANT: It seems that a multi-paradigm does not necessarily support all relations, scenarios, and intents
of a conceptually included or conceptually equal one.
For example, the ODE (ordinary differential equation) paradigm is a single-formalism paradigm and a core
paradigm that captures only the continuous and timed behaviour features of the behavior dimension, but not
the discrete behavior feature, the automata paradigm is a single-formalism paradigm and a core paradigm that
captures only the discrete feature of the behavior dimension, but not the continuous and timed behaviour features, and the hybrid automata paradigm is a single-formalism paradigm and a multi-paradigm, as it employs only one
formalism but includes the automata and ODEs paradigms and their features of discrete, continuous, and timed
behaviour for the behavior dimension.
In contrast, the Simulink/Stateflow paradigm is a multi-formalism paradigm and a multi-paradigm, as it employs
both the Simulink and Stateflow formalism and includes the Simulink and Stateflow paradigms that are conceptually
similar to ODEs and automata.
}

\todo[inline]{From HG's internal document:\\
Forms of Multi-Paradigm Scenarios
Given formalisms supporting paradigms, multi-paradigm scenarios can operate in three different ways:
- Language-based: Having a single-formalism paradigm that includes multiple core paradigms (e.g., hybrid
automata)
- Composition-based: We compose formalism supporting different paradigms into a single one by a suitable
model of computation that composes the multiple formalisms (e.g., Simulink/Stateflow)
- Tool-based: We compose formalisms supporting different paradigms via tools (e.g., co-simulation of a
Simulink model and a plant model)
Definition 5 (multi-paradigm scenario) A multi-paradigm scenario is a scenario which covers parts of scenarios
from at least two core paradigms.}

\todo[inline]{ Exampels from HG's document:\\
-Example of language-based Multi-Paradigm Scenarios
Hybrid automata
HGTS\\
-Example of Composition-based Multi-Paradigm Scenarios: Ptolemy
https://ptolemy.berkeley.edu/
Ptolemy II
ptolemy.berkeley.edu/ptolemyII/\\
Examples for Tool-based Multi-Paradigm Scenarios
Matlab/Simulink with Stateflow for the software and a configuration for RoboSim are coupled via co-simulation (see
Figure 3 middle, where the models are coupled via coupling of the Matlab/Simulink and RoboSim simulators).
Matlab/Simulink with Stateflow for the software and Robot as rapid prototype can also be coupled by linking the
Matlab/Simulink simulator with the execution of the robot (see Figure 3 bottom: coupled via coupling of simulator
and robot (exec)).
Matlab/Simulink with Stateflow for the software functions and AUTOSAR SystemDesk for the software architecture
build a multi-formalism coupling that is resolved by linking the generated c-code and executed together
with a rapid prototype of the plant (see Figure 4 middle, where the execution of the software is coupled with a
robot).
final outcome where all is mapped to the execution on one host:
Matlab/Simulink with Stateflow for the software functions and AUTOSAR SystemDesk for the software architecture
build a multi-formalism coupling that is resolved by linking the generated c-code and executed together with a rapid prototype of the plant (see where the execution of the software is done on the robot on the HPI CPS Lab)}

We postulate that a more formal definition of \textit{paradigm} should be shaped as a set of logical bindings between the set of modeling \textit{formalisms} involved in a given modeling approach, the set of \textit{relationships} between the used models based on the selected formalisms, the \textit{workflow(s)} used to manipulate such models respecting the established relationships and the \textit{intents and goals} that drive the manipulations and state the desired results of the whole modeling process.
\textit{Conformity to a paradigm} should then be expressed in terms of the validity of a set \textit{properties} over those 4 elements.

We argue such a definition, that still lacks the notion of \textit{primitive paradigm}, by looking at a number of popular model-based approaches, that are characterized (and recognizable) by these four aspects, in explicit or tacit conformance to formally or informally defined practices. Let us consider as examples of candidate modeling paradigms Agile Programming (AP) \cite{}, Model Based Software Engineering (MBSE) \cite{}, Model Driven Software Engineering (MDSE) \cite{}, Roundtrip Software Engineering (RSE) \cite{}, that are well known software development methodologies, and, as diverse elements, Reverse Engineering (RE) \cite{} and Multi Formalism Modeling\footnote{Multi Formalism Modeling is the generic denomination of a family of different approaches that are founded onto enabling the modeling of a system by means of different modeling formalism, that may be coordinately used for different aspects, different subsystems, different components or different modeling stages of a system.} (MFM) \cite{MauroChapter}, that is oriented to performance evaluation, as working examples.

With no claim for a complete analysis of goals and intents, AP, MBSE, MDSE and RSE share a common goals, that is the production of software artifacts. MBSE, MDSE and RSE share an intent, that is the will for supporting the team in obtaining shareable, clear, verifiable, extensible, evolveable, documentation oriented design artifacts by the adoption of a formal notation, with the additional goal of a certifiable process and a quality final result, while AP has the intent of simplifying the team organization and management and supporting a fast and continuous development and release process including frequent user revisions, with the additional goal of a continuous deployment, rather than an incremental approach. MDE has the additional goal of automatic code generation by transformation with the intent of avoiding human generated errors along the development process, while RSE has the additional goal of a complete and automatic equivalence between models and code, with the intent of completely automating both code generation and model maintenance.

RE instead has the goal of obtaining models from code, by means of a manual, semi-automated or automated analysis, with the intent of producing missing documentation or artifacts that may be used to reengineer the code or include legacy code into new projects. Finally, MFM as the goal of producing a performance estimation of a given system, with the intent of supporting the design process of the system with quantitative exploration of its characteristics to guide decisions when alternative solutions are possible.

In all cases there is a set of formalisms\footnote{The term \textit{formalism} here both stays for actually fully formal specified modeling language or for semi-formal modeling languages (such as the widely adopted Entity/Relationship modeling language).} that are adopted to generate models supporting the approach. MBSE, MDSE, RSE and RE generally adopt the Unified Modeling Language (UML) as the set of support formalisms, or a subset or custom variant of UML, while AP generally relies on the use of code as a model, and MFM approaches rely on a various, generally extensible set of formalisms, depending on the application, that may encompass UML itself or some annotated or extended variants of it, but that is anyway not specifically agreed in literature.

Exploring relationships between the formalisms used in each of these approaches would be long and tedious, but we argue that relationships are characteristics of a modeling paradigm because different modeling approaches that share a set of modeling paradigms make a different use of them and coordinate models founded on them in a different way, yet keep being sound and fit for their intents and goals. In some cases these relationships are clearly formally stated by the approach (e.g. MDE and RTSE rely on formally defined automatic model transformations), in other cases the modelers have the freedom to customize or propose the relationships (e.g. MBSE, in which at least code production is not obtained by a strict mapping of models and code), according to own modeling style or to the domain, in other cases a formal definition of them is prescribed by certification processes, in other cases relationships emerge or may be custom built by exploiting some properly designed mechanism (e.g. OsMoSys \cite{OsMoSys} and SIMTHESys \cite{SIMTHESys} MFM approaches found relationships between formalisms on metamodeling). Anyway, coordination practices or best practices of models in a project described in different formalisms do implicitly define such relationships.

Workflows drive and depict the practices used in the different approaches, partially expliciting relationships and describing how models are applied, revised, transformed, reused, composed, evolved legitimately in the chosen approach. Literature and practice provide both structured and non-structured approaches, while we argue that structured workflows are needed to comply to our definition.

TODO: A comparison table and a more detailed analysis on the same line

TODO: Figure depicting MBSE, MDSE, RSE and RE as from Paris

\subsection{The way for a formal definition}

In order to get to a formal definition of paradigm, we need to formalize this analysis framework. This includes the establishment of an analysis procedure for the candidate paradigms that includes the definition of upper and lower abstraction bounds, in terms of what is the most elementary paradigm possible (a \textit{primitive paradigm}) and what is so complex to be actually the result of the joined application of multiple paradigms (a \textit{multiparadigm}).

A possible interpretation of the idea of primitive paradigm may be a simple single formalism modeling process, such as Differential Equations (DE), Petri Nets (PN), Fault Trees (FT), or a programming language: all these cases have a simple and well defined goal and intent, use one formally defined formalism to allow the design of models, have a straightforward workflow (if considering as the workflow the practical process of writing a model).

A possible definition of multiparadigm can be shaped by leveraging the need for a semantic approach when joining together concepts from different domains. This need derives from the fact that a mapping between modeling entities in different areas is only possible by considering the meaning of such entities in their domain and the meaning of the logical binding built by the modeler when deciding to coordinate different paradigms to get to a more significant and comprehensive conceptual modeling tool. One may argue that structured approaches like MBSE already bind by workflows concepts that may be considered belonging to different domains, by associating different models in a workflow: nevertheless, our opinion is that the semantic binding should not be trivial, that is, it should be not induced by the fact that different models are simply different specialized views on the same object, or that it should not be related to modeling a different characteristic of a same entity. Alternatively, less strict criteria may be used than strong semantic boudaries, considering that there is anyway the need for a notion of \textit{meaningful multiparadigm}: for example, the classical Waterfall Development Model (WDM) for software and AP cannot be joined into a multiparadigm, as they share the same main goal, that is the production of software artifacts, but they have conflicting intents, as the first one foresees a structured, "heavy", integral development process, while the second is based on incremental, non-structured, evolutive development).

On the basis of the four elements presented in the beginning of this Section, we propose the following definition: \textit{A paradigm is a coherent system of modeling formalisms, relationships between formalisms, workflows that allow model manipulations with stated intents and precise goals, all characterized by a set of properties}; a paradigm can be thus formally expressed as $P=\{\langle F,W,I,G>, \mathcal{R}, \pi \}$, where $F$ is the set of formalisms, $W$ is the set of workflows, $I$ is the set of intents, $G$ is the set of goals, $\mathcal{R}$ is the set of relationships, $\pi =\{p_i\}$ is the set of reference properties, **** named \textit{constraints} ****, that characterize paradigm $P$. A coherency with $\{p_i\}$ check on a generic quadruple with the same structure of $<F,W,I,G>$, to verify if such quadruple is coherent with $P$, must be performed by a proper \textit{coherency function} $\models$. Analogously, a multiparadigm $MP=P_1 \times P_2$, characterized by $\{<F_\mathit{MP},W_{MP},I_{MP},G_{MP}>, \mathcal{R}_{MP}, \pi_{MP}\}$, is a combination of 2 (or more) paradigms $P_1$ and $P_2$, characterized by $\{< F_1,W_1,I_1,G_1>, \mathcal{R}_1 , \pi_1\}$ and $\{<F_2,W_2,I_2,G_2>, \mathcal{R}_2, \pi_2\}$: to completely define a multiparadigm we need a definition of the relationship between $<F_{MP},W_{MP},I_{MP},G_{MP}>$ and the couple $(< F_1,W_1,I_1,G_1>,<F_2,W_2,I_2,G_2>)$, and the notion of metaconstraints to represent $\pi_{MP}$, that may not simply be a combination of $\pi_1$ and $\pi_2$, e.g. if the semantic approach is taken as the basis for delimiting the border between paradigms and a multiparadigm **** what about $\mathcal{R_{MP}}$, $\mathcal{R}_1$ and $\mathcal{R}_2$? ****. Multiparadigm also need an extension of the notion of coherency used in the proposed definition of paradigm.

The coherency relation itself needs a definition. It can be defined as specific to a given paradigm, thus introducing a $\models_i$ for each paradigm $P_i$, or as an universal notion applicable to all paradigm in the same way: and it is significant, from an operative point of view, if coherency with metaconstraints should be a decision procedure over properties to be performed by humans of computers, as it implies a different degree of formalization of the notion of coherence and of the notion of metaconstraints.
